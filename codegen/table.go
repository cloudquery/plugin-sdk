package codegen

import (
	"bytes"
	"embed"
	"fmt"
	"go/format"
	"log"
	"os"
	"path"
	"reflect"
	"strings"
	"text/template"

	"github.com/cloudquery/plugin-sdk/schema"
	"github.com/iancoleman/strcase"
	"github.com/thoas/go-funk"
	"golang.org/x/exp/slices"
)

type (
	ResourceDefinition struct {
		Name  string
		Table *TableDefinition
	}
	TableDefinition struct {
		// Table name is, by default, `{plugin_name}_{service_name}_{subservice_name}`.
		// It can be overridden by setting the NameOverride field.
		PluginName   string
		Service      string
		SubService   string
		NameOverride string

		// These are fairly strightforward string fields that are used as-is in the schema template.
		Description          string
		Relations            []string
		Multiplex            string
		PreResourceResolver  string
		PostResourceResolver string

		// All the following fields determine how the column-definitions will be autogenerated.
		Struct                        interface{}
		NameTransformer               NameTransformer
		TypeTransformer               TypeTransformer
		ResolverTransformer           ResolverTransformer
		ExtraColumns                  ColumnDefinitions
		PKColumns                     []string
		SkipFields                    []string
		StructFieldsToUnwrap          []string
		UnwrapAllEmbeddedStructFields bool
	}
)

//go:embed templates/*.go.tpl
var templatesFS embed.FS

func (t *TableDefinition) shouldIgnoreField(field reflect.StructField) bool {
	switch {
	case len(field.Name) == 0,
		slices.Contains(t.SkipFields, field.Name),
		!field.IsExported(),
		isTypeIgnored(field.Type):
		return true
	default:
		return false
	}
}

// Generates a `.SubService.go` file in a `.Service` subdirectory of provided `dir`.
func (t *TableDefinition) GenerateSchema(dir string) error {
	if err := t.Check(); err != nil {
		return err
	}

	tpl, err := template.New("table.go.tpl").Funcs(template.FuncMap{
		"ToCamel": strcase.ToCamel,
		"ToLower": strings.ToLower,
	}).ParseFS(templatesFS, "templates/*.go.tpl")

	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	var buff bytes.Buffer
	if err := tpl.Execute(&buff, t); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	filepath := path.Join(dir, t.Service, t.SubService+".go")
	content := buff.Bytes()
	formattedContent, err := format.Source(content)

	if err != nil {
		return fmt.Errorf("failed to format source: %s, %w", filepath, err)
	}

	if err := os.MkdirAll(path.Join(dir, t.Service), os.ModePerm); err != nil {
		return fmt.Errorf("failed to create directory: %s, %w", dir, err)
	}

	if err := os.WriteFile(filepath, formattedContent, 0644); err != nil {
		return fmt.Errorf("failed to write file %s: %w", filepath, err)
	}

	return nil
}

// Check that the resulting TableDefinition is correct (e.g., no overlapping column names).
func (t *TableDefinition) Check() error {
	if t == nil {
		return fmt.Errorf("nil table definition")
	}

	name, err := t.Name()
	if err != nil {
		return err
	}
	if len(name) == 0 {
		return fmt.Errorf("empty table name")
	}

	columns, err := t.Columns()
	if err != nil {
		return err
	}

	if len(columns) == 0 {
		return fmt.Errorf("%s: no columns", name)
	}

	columnsMap := make(map[string]bool, len(columns))
	for _, column := range columns {
		switch {
		case len(column.Name) == 0:
			return fmt.Errorf("%s: empty column name", name)
		case column.Type == schema.TypeInvalid:
			return fmt.Errorf("%s->%s: invalid column type", name, column.Name)
		case columnsMap[column.Name]:
			return fmt.Errorf("%s->%s: duplicate column name", name, column.Name)
		default:
			columnsMap[column.Name] = true
		}
	}

	return nil
}

// The receiver must not be a pointer, because this method is called from a template.
func (t TableDefinition) Columns() (ColumnDefinitions, error) {
	e := reflect.ValueOf(t.Struct)
	if e.Kind() == reflect.Pointer {
		e = e.Elem()
	}
	if e.Kind() == reflect.Slice {
		e = reflect.MakeSlice(e.Type(), 1, 1).Index(0)
	}
	if e.Kind() != reflect.Struct {
		return nil, fmt.Errorf("expected struct, got %s", e.Kind())
	}

	var columns ColumnDefinitions

	columns = append(columns, t.ExtraColumns...)

	eType := e.Type()
	for i := 0; i < e.NumField(); i++ {
		field := eType.Field(i)

		switch {
		case t.shouldUnwrapField(field):
			fieldColumns, err := t.unwrapField(field)
			if err != nil {
				return nil, err
			}
			columns = append(columns, fieldColumns...)

		default:
			fieldColumns, err := t.makeColumnFromField(field, nil)
			if err != nil {
				return nil, fmt.Errorf("failed to add column for field %s: %w", field.Name, err)
			}
			columns = append(columns, fieldColumns...)
		}
	}

	// We make sure that no "pk-columns" definitions are left "orphaned".
	pkColumnsMap := makeSetFromSlice(t.PKColumns)
	for i := range columns { // TODO: QQQ: make sure no extra PK columns

		if slices.Contains(t.PKColumns, columns[i].Name) {
			columns[i].Options.PrimaryKey = true
			delete(pkColumnsMap, columns[i].Name)
		}
	}

	if len(pkColumnsMap) > 0 {
		name, err := t.Name()
		if err != nil {
			log.Print("failed getting table name:", err)
		}
		return nil, fmt.Errorf("%s table definition has %d extra PK keys: %v", name, len(pkColumnsMap), funk.Keys(pkColumnsMap))
	}

	return columns, nil
}

// The receiver must not be a pointer, because this method is called from a template.
func (t TableDefinition) Name() (string, error) {
	var name string

	if len(t.NameOverride) > 0 {
		name = t.NameOverride
	} else {
		if t.PluginName == "" || t.Service == "" || t.SubService == "" {
			return "", fmt.Errorf("unable to generate table name: missing fields (pluginName, service, subService)")
		}
		name = fmt.Sprintf("%s_%s_%s", t.PluginName, t.Service, t.SubService)
	}

	if !strings.HasSuffix(name, "s") {
		return "", fmt.Errorf("invalid table name: %s. must be plural", name)
	}

	return name, nil
}

// The receiver must not be a pointr, because this method is called from a template.
func (t TableDefinition) Resolver() string {
	return "fetch" + strcase.ToCamel(t.Service) + strcase.ToCamel(t.SubService)
}

func makeSetFromSlice(slice []string) map[string]bool {
	set := make(map[string]bool, len(slice))
	for _, s := range slice {
		set[s] = true
	}
	return set
}
